<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Quitar Fondo ‚Äî Stikeria (conserva color, borde liso)</title>
<style>
  body{font-family:Arial, sans-serif;background:#0f1014;color:#eef1f6;margin:0;padding:20px}
  .box{max-width:760px;margin:auto;background:#151826;border:1px solid #262a3f;border-radius:16px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.35)}
  h2{margin:0 0 10px;text-align:center}
  .bar{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-bottom:10px}
  button{padding:10px 14px;border:0;border-radius:10px;font-weight:800;cursor:pointer}
  #btnUp{background:#2c7be5;color:#fff}
  #btnGo{background:#34c38f;color:#fff}
  #btnDl{background:#e83e8c;color:#fff}
  canvas{width:100%;background:#0f111a;border-radius:10px;cursor:crosshair}
  .mini{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;align-items:center;margin:8px 0 4px}
  .mini label{font-size:12px;color:#cfe1ff;display:flex;align-items:center;gap:6px}
  input[type="range"]{accent-color:#2c7be5}
  .chip{background:#202540;border:1px solid #2f365c;border-radius:999px;padding:2px 8px}
</style>
</head>
<body>
<div class="box">
  <h2>Quitar Fondo ‚Äî Stikeria (conserva color)</h2>
  <div class="bar">
    <button id="btnUp">Subir imagen</button>
    <input id="file" type="file" accept="image/png,image/jpeg,image/webp" style="display:none">
    <button id="btnGo" disabled>Quitar fondo</button>
    <button id="btnDl" disabled>Descargar 512√ó512</button>
  </div>

  <div class="mini">
    <label>üéØ Fondo:
      <select id="bgMode">
        <option value="auto">Auto (esquinas)</option>
        <option value="click">Elegir con clic</option>
      </select>
      <span id="bgChip" class="chip">auto</span>
    </label>
    <label>üéöÔ∏è Tolerancia (base)
      <input id="tol" type="range" min="20" max="100" value="60">
      <span id="tolv" class="chip">60</span>
    </label>
    <label>üõ°Ô∏è Protecci√≥n dibujo
      <input id="prot" type="range" min="5" max="30" value="18">
      <span id="protv" class="chip">18</span>
    </label>
    <label>üß∑ Banda borde (px)
      <input id="band" type="range" min="1" max="5" value="2">
      <span id="bandv" class="chip">2</span>
    </label>
    <label><input id="holes" type="checkbox" checked> Quitar islas internas</label>
    <label><input id="smoothEdge" type="checkbox" checked> Borde liso</label>
    <label><input id="protectColors" type="checkbox" checked> Proteger vidrios/amarillos</label>
  </div>

  <canvas id="cv" title="Si 'Fondo: Elegir con clic' est√° activo, toca el fondo"></canvas>
</div>

<script>
(function(){
  const q=id=>document.getElementById(id);
  const cv=q('cv'), ctx=cv.getContext('2d',{willReadFrequently:true});
  const btnUp=q('btnUp'), file=q('file'), btnGo=q('btnGo'), btnDl=q('btnDl');
  const tol=q('tol'), tolv=q('tolv'), prot=q('prot'), protv=q('protv'), band=q('band'), bandv=q('bandv');
  const holes=q('holes'), smoothEdge=q('smoothEdge'), protectColors=q('protectColors');
  const bgMode=q('bgMode'), bgChip=q('bgChip');

  let img=null, W=0, H=0, bg={r:255,g:255,b:255};

  tol.oninput = ()=> tolv.textContent = tol.value;
  prot.oninput= ()=> protv.textContent = prot.value;
  band.oninput = ()=> bandv.textContent = band.value;

  btnUp.onclick=()=>file.click();
  file.onchange=e=>{
    const f=e.target.files?.[0]; if(!f) return;
    img=new Image();
    img.onload=()=>{
      W=img.naturalWidth; H=img.naturalHeight;
      cv.width=W; cv.height=H;
      ctx.clearRect(0,0,W,H); ctx.drawImage(img,0,0,W,H);
      btnGo.disabled=false; btnDl.disabled=true;
      bg = autoSampleBackground(cv); setChip(bg);
    };
    img.src=URL.createObjectURL(f);
  };

  cv.addEventListener('click', e=>{
    if(bgMode.value!=="click" || !img) return;
    const r=cv.getBoundingClientRect();
    const x=Math.floor((e.clientX-r.left)*(cv.width/r.width));
    const y=Math.floor((e.clientY-r.top)*(cv.height/r.height));
    const p=ctx.getImageData(x,y,1,1).data;
    bg={r:p[0],g:p[1],b:p[2]}; setChip(bg);
  });

  btnGo.onclick=()=>{
    if(!img) return;
    if(bgMode.value==="auto"){ bg=autoSampleBackground(cv); setChip(bg); }
    const src=ctx.getImageData(0,0,W,H);
    const mask = buildMaskConserv(src, Number(tol.value)/100, Number(prot.value)/100, holes.checked, protectColors.checked);
    applyAlphaTrimap(src, mask, smoothEdge.checked, Number(band.value));
    btnDl.disabled=false;
  };

  btnDl.onclick=()=>{
    const out=document.createElement('canvas'); out.width=512; out.height=512;
    const c=out.getContext('2d'); c.imageSmoothingEnabled=true; c.imageSmoothingQuality='high';
    const s=Math.min(512/W,512/H), nw=W*s, nh=H*s;
    c.clearRect(0,0,512,512);
    c.drawImage(cv,(512-nw)/2,(512-nh)/2,nw,nh);
    const a=document.createElement('a'); a.download='sticker_512.png'; a.href=out.toDataURL('image/png'); a.click();
  };

  function setChip(c){ bgChip.textContent = `rgb(${c.r|0},${c.g|0},${c.b|0})`; }

  // ---------- util color ----------
  function srgbToLinear(u){ u/=255; return u<=0.04045?u/12.92:Math.pow((u+0.055)/1.055,2.4); }
  function rgb2oklab(r,g,b){
    const R=srgbToLinear(r), G=srgbToLinear(g), B=srgbToLinear(b);
    const l=0.4122214708*R+0.5363325363*G+0.0514459929*B;
    const m=0.2119034982*R+0.6806995451*G+0.1073969566*B;
    const s=0.0883024619*R+0.2817188376*G+0.6299787005*B;
    const l_=Math.cbrt(l), m_=Math.cbrt(m), s_=Math.cbrt(s);
    return {
      L:0.2104542553*l_+0.7936177850*m_-0.0040720468*s_,
      a:1.9779984951*l_-2.4285922050*m_+0.4505937099*s_,
      b:0.0259040371*l_+0.7827717662*m_-0.8086757660*s_
    };
  }
  function deltaOk(a,b){ const dL=a.L-b.L, da=a.a-b.a, db=a.b-b; return Math.hypot(dL,da,db); } // simple
  function toGray(data,w,h){ const g=new Uint8ClampedArray(w*h); for(let i=0,p=0;i<data.length;i+=4,p++){ g[p]=(0.299*data[i]+0.587*data[i+1]+0.114*data[i+2])|0; } return g; }
  function sobel(gray,w,h){ const out=new Uint8ClampedArray(w*h);
    for(let y=1;y<h-1;y++){ for(let x=1;x<w-1;x++){
      const i=y*w+x;
      const gx=-gray[i-w-1]-2*gray[i-1]-gray[i+w-1]+gray[i-w+1]+2*gray[i+1]+gray[i+w+1];
      const gy=-gray[i-w-1]-2*gray[i-w]-gray[i-w+1]+gray[i+w-1]+2*gray[i+w]+gray[i+w+1];
      out[i]=Math.min(255, Math.hypot(gx,gy)|0);
    }} return out;
  }

  // ---------- morphology ----------
  function dilate(mask,w,h){ const src=mask, out=new Uint8ClampedArray(src.length);
    for(let y=0;y<h;y++){ for(let x=0;x<w;x++){
      const id=y*w+x; if(src[id]){ out[id]=1; continue; }
      let on=0;
      for(let yy=y-1;yy<=y+1;yy++){ for(let xx=x-1;xx<=x+1;xx++){
        if(xx<0||yy<0||xx>=w||yy>=h) continue;
        if(src[yy*w+xx]){ on=1; break; }
      } if(on) break; }
      out[id]=on?1:0;
    }} return out;
  }

  // ---------- background sample ----------
  function autoSampleBackground(c){
    const cx=c.getContext('2d'), w=c.width, h=c.height;
    const s=Math.max(6,Math.floor(Math.min(w,h)*0.06));
    const patches=[ cx.getImageData(0,0,s,s).data, cx.getImageData(w-s,0,s,s).data, cx.getImageData(0,h-s,s,s).data, cx.getImageData(w-s,h-s,s,s).data ];
    let R=0,G=0,B=0,N=0; for(const data of patches){ for(let i=0;i<data.length;i+=4){ R+=data[i]; G+=data[i+1]; B+=data[i+2]; N++; } }
    return {r:R/N, g:G/N, b:B/N};
  }

  // ---------- m√°scara conservadora con trimap ----------
  function buildMaskConserv(src, tolBase, protGap, removeHoles, protectCol){
    const d=src.data, w=src.width, h=src.height;
    const bgLab=rgb2oklab(bg.r,bg.g,bg.b);
    const edges = sobel(toGray(d,w,h), w, h);
    const edgeThr = 24;

    // Umbrales: Tbg < delta <= Tfg
    const Tbg = tolBase*0.85 + 0.08;      // fondo seguro (m√°s peque√±o = m√°s f√°cil borrar)
    const Tfg = Tbg + (protGap*0.5);      // sticker seguro (m√°s grande = m√°s protecci√≥n)

    const fgSure=new Uint8Array(w*h);
    const bgSure=new Uint8Array(w*h);
    const unknown=new Uint8Array(w*h);

    for(let i=0,p=0;i<d.length;i+=4,p++){
      const r=d[i], g=d[i+1], b=d[i+2];
      const lab=rgb2oklab(r,g,b);
      const delta=deltaOk(lab,bgLab);

      // proteger blanco puro (contorno blanco)
      const mx=Math.max(r,g,b), mn=Math.min(r,g,b);
      const whitePure = (mx>245 && mn>225);

      // proteger bordes fuertes
      const isEdge = edges[p] > edgeThr;

      // proteger colores saturados (vidrios/amarillos)
      let protect = false;
      if(protectCol){
        const s = Math.max(mx - ((r+g+b-mx)/2), 0)/255; // aprox saturaci√≥n r√°pida
        protect = s>0.22 || isEdge || whitePure;
      }

      if(whitePure || isEdge || protect){
        fgSure[p]=1; continue;
      }

      if(delta <= Tbg) { bgSure[p]=1; }
      else if(delta >= Tfg) { fgSure[p]=1; }
      else { unknown[p]=1; }
    }

    // Limitar fondo a lo conectado a bordes (evita comerse ‚Äúhuecos‚Äù interiores por error)
    const bgConn = floodFromEdges(bgSure,w,h);

    // Construir alpha base:
    // - 0 en bgConn
    // - 1 en fgSure
    // - [0..1] en unknown segun delta relativo entre Tbg..Tfg (suave, sin tocar color)
    const A=new Float32Array(w*h);
    for(let i=0,p=0;i<d.length;i+=4,p++){
      if(bgConn[p]) { A[p]=0; continue; }
      if(fgSure[p]) { A[p]=1; continue; }
      if(unknown[p]) {
        const r=d[i], g=d[i+1], b=d[i+2];
        const lab=rgb2oklab(r,g,b);
        const delta=deltaOk(lab,bgLab);
        const a=(delta-Tbg)/Math.max(1e-6, (Tfg-Tbg));
        A[p]=Math.max(0,Math.min(1,a));
      } else {
        A[p]=1; // por seguridad
      }
    }

    return {alpha:A, w, h};
  }

  function floodFromEdges(mask,w,h){
    const visited=new Uint8Array(w*h);
    const st=[]; const push=(x,y)=>st.push(x,y);
    // bordes
    for(let x=0;x<w;x++){ if(mask[x]){visited[x]=1; push(x,0);} if(mask[(h-1)*w+x]){visited[(h-1)*w+x]=1; push(x,h-1);} }
    for(let y=0;y<h;y++){ if(mask[y*w]){visited[y*w]=1; push(0,y);} if(mask[y*w+(w-1)]){visited[y*w+(w-1)]=1; push(w-1,y);} }
    while(st.length){
      const y=st.pop(), x=st.pop(), id=y*w+x;
      if(x>0){ const i1=id-1; if(!visited[i1] && mask[i1]){visited[i1]=1; push(x-1,y);} }
      if(x<w-1){ const i2=id+1; if(!visited[i2] && mask[i2]){visited[i2]=1; push(x+1,y);} }
      if(y>0){ const i3=id-w; if(!visited[i3] && mask[i3]){visited[i3]=1; push(x,y-1);} }
      if(y<h-1){ const i4=id+w; if(!visited[i4] && mask[i4]){visited[i4]=1; push(x,y+1);} }
    }
    return visited;
  }

  // ---------- aplicar alpha con banda de borde lisa ----------
  function applyAlphaTrimap(src, maskObj, doSmooth, bandPx){
    const {alpha:A0, w, h} = maskObj;
    const d=src.data;

    // detectar borde (transici√≥n) y crear banda (dilatando)
    let boundary=new Uint8Array(w*h);
    for(let y=1;y<h-1;y++){ for(let x=1;x<w-1;x++){
      const id=y*w+x, a=A0[id];
      if((a>0 && a<1) || (A0[id-1]!==a || A0[id+1]!==a || A0[id-w]!==a || A0[id+w]!==a)){
        boundary[id]=1;
      }
    }}
    for(let t=1;t<bandPx;t++) boundary=dilate(boundary,w,h);

    // blur solo en la banda
    const A=new Float32Array(A0); // copia
    if(doSmooth){
      const B=new Float32Array(A.length);
      for(let y=1;y<h-1;y++){ for(let x=1;x<w-1;x++){
        const id=y*w+x;
        if(boundary[id]){
          let s=0;
          s+=A[id]+A[id-1]+A[id+1]+A[id-w]+A[id+w]+A[id-w-1]+A[id-w+1]+A[id+w-1]+A[id+w+1];
          B[id]=s/9;
        } else {
          B[id]=A[id];
        }
      }}
      for(let i=0;i<A.length;i++) A[i]=B[i];
    }

    // endurecer un poquito para evitar velos grises, sin tocar interior opaco
    for(let i=0;i<A.length;i++){
      let a=A[i];
      if(a<0.02) a=0; else if(a>0.98) a=1; else a=Math.pow(a,0.92);
      A[i]=a;
    }

    // aplicar: NO tocamos color. blanco puro siempre 100% opaco
    for(let i=0,p=0;i<d.length;i+=4,p++){
      const r=d[i], g=d[i+1], b=d[i+2];
      const mx=Math.max(r,g,b), mn=Math.min(r,g,b);
      if(mx>245 && mn>225){ d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=255; continue; }
      d[i+3]=Math.round(A[p]*255);
    }
    ctx.putImageData(src,0,0);
  }
})();
</script>
</body>
</html>
