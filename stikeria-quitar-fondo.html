<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Quitar Fondo ‚Äî Stikeria (cristales OK, sin manchitas)</title>
<style>
  body{font-family:Arial, sans-serif;background:#0f1014;color:#eef1f6;margin:0;padding:20px}
  .box{max-width:760px;margin:auto;background:#151826;border:1px solid #262a3f;border-radius:16px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.35)}
  h2{margin:0 0 10px;text-align:center}
  .bar{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-bottom:10px}
  button{padding:10px 14px;border:0;border-radius:10px;font-weight:800;cursor:pointer}
  #btnUp{background:#2c7be5;color:#fff}
  #btnGo{background:#34c38f;color:#fff}
  #btnDl{background:#e83e8c;color:#fff}
  canvas{width:100%;background:#0f111a;border-radius:10px;cursor:crosshair}
  .mini{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;align-items:center;margin:8px 0 4px}
  .mini label{font-size:12px;color:#cfe1ff;display:flex;align-items:center;gap:6px}
  input[type="range"]{accent-color:#2c7be5}
  .chip{background:#202540;border:1px solid #2f365c;border-radius:999px;padding:2px 8px}
</style>
</head>
<body>
<div class="box">
  <h2>Quitar Fondo ‚Äî Stikeria (cristales OK)</h2>
  <div class="bar">
    <button id="btnUp">Subir imagen</button>
    <input id="file" type="file" accept="image/png,image/jpeg,image/webp" style="display:none">
    <button id="btnGo" disabled>Quitar fondo</button>
    <button id="btnDl" disabled>Descargar 512√ó512</button>
  </div>

  <div class="mini">
    <label>üéØ Fondo:
      <select id="bgMode">
        <option value="auto">Auto (esquinas)</option>
        <option value="click">Elegir con clic</option>
      </select>
      <span id="bgChip" class="chip">auto</span>
    </label>
    <label>üéöÔ∏è Tolerancia
      <input id="tol" type="range" min="20" max="100" value="60">
      <span id="tolv" class="chip">60</span>
    </label>
    <label>üß∑ Banda borde (px)
      <input id="band" type="range" min="1" max="5" value="2">
      <span id="bandv" class="chip">2</span>
    </label>
    <label><input id="fillHoles" type="checkbox" checked> Rellenar huecos internos (cristales)</label>
    <label><input id="cleanSpecks" type="checkbox" checked> Quitar puntitos/manchas</label>
    <label><input id="smoothEdge" type="checkbox" checked> Borde liso</label>
  </div>

  <canvas id="cv" title="Si 'Fondo: Elegir con clic' est√° activo, toca el fondo"></canvas>
</div>

<script>
(function(){
  const q=id=>document.getElementById(id);
  const cv=q('cv'), ctx=cv.getContext('2d',{willReadFrequently:true});
  const btnUp=q('btnUp'), file=q('file'), btnGo=q('btnGo'), btnDl=q('btnDl');
  const tol=q('tol'), tolv=q('tolv'), band=q('band'), bandv=q('bandv');
  const bgMode=q('bgMode'), bgChip=q('bgChip');
  const fillHoles=q('fillHoles'), cleanSpecks=q('cleanSpecks'), smoothEdge=q('smoothEdge');

  let img=null, W=0, H=0, bg={r:255,g:255,b:255};

  tol.oninput=()=>tolv.textContent=tol.value;
  band.oninput=()=>bandv.textContent=band.value;

  btnUp.onclick=()=>file.click();
  file.onchange=e=>{
    const f=e.target.files?.[0]; if(!f) return;
    img=new Image();
    img.onload=()=>{
      W=img.naturalWidth; H=img.naturalHeight;
      cv.width=W; cv.height=H;
      ctx.clearRect(0,0,W,H); ctx.drawImage(img,0,0,W,H);
      btnGo.disabled=false; btnDl.disabled=true;
      bg = autoSampleBackground(cv); setChip(bg);
    };
    img.src=URL.createObjectURL(f);
  };

  cv.addEventListener('click', e=>{
    if(bgMode.value!=="click" || !img) return;
    const r=cv.getBoundingClientRect();
    const x=Math.floor((e.clientX-r.left)*(cv.width/r.width));
    const y=Math.floor((e.clientY-r.top)*(cv.height/r.height));
    const p=ctx.getImageData(x,y,1,1).data;
    bg={r:p[0],g:p[1],b:p[2]}; setChip(bg);
  });

  btnGo.onclick=()=>{
    if(!img) return;
    if(bgMode.value==="auto"){ bg=autoSampleBackground(cv); setChip(bg); }
    const src=ctx.getImageData(0,0,W,H);
    const mask = buildMaskKeepGlass(src, Number(tol.value)/100, fillHoles.checked, cleanSpecks.checked);
    applyAlphaWithSmooth(src, mask, smoothEdge.checked, Number(band.value));
    btnDl.disabled=false;
  };

  btnDl.onclick=()=>{
    const out=document.createElement('canvas'); out.width=512; out.height=512;
    const c=out.getContext('2d'); c.imageSmoothingEnabled=true; c.imageSmoothingQuality='high';
    const s=Math.min(512/W,512/H), nw=W*s, nh=H*s;
    c.clearRect(0,0,512,512);
    c.drawImage(cv,(512-nw)/2,(512-nh)/2,nw,nh);
    const a=document.createElement('a'); a.download='sticker_512.png'; a.href=out.toDataURL('image/png'); a.click();
  };

  function setChip(c){ bgChip.textContent=`rgb(${c.r|0},${c.g|0},${c.b|0})`; }

  // ---------- util color ----------
  function srgbToLinear(u){ u/=255; return u<=0.04045?u/12.92:Math.pow((u+0.055)/1.055,2.4); }
  function rgb2oklab(r,g,b){
    const R=srgbToLinear(r), G=srgbToLinear(g), B=srgbToLinear(b);
    const l=0.4122214708*R+0.5363325363*G+0.0514459929*B;
    const m=0.2119034982*R+0.6806995451*G+0.1073969566*B;
    const s=0.0883024619*R+0.2817188376*G+0.6299787005*B;
    const l_=Math.cbrt(l), m_=Math.cbrt(m), s_=Math.cbrt(s);
    return {
      L:0.2104542553*l_+0.7936177850*m_-0.0040720468*s_,
      a:1.9779984951*l_-2.4285922050*m_+0.4505937099*s_,
      b:0.0259040371*l_+0.7827717662*m_-0.8086757660*s_
    };
  }
  function deltaOk(a,b){ const dL=a.L-b.L, da=a.a-b.a, db=a.b-b.b; return Math.sqrt(dL*dL+da*da+db*db); }

  // ---------- morphology ----------
  function erode255(mask,w,h){ const src=mask, out=new Uint8ClampedArray(src.length);
    for(let y=0;y<h;y++){ for(let x=0;x<w;x++){
      const id=y*w+x; if(src[id]===0){ out[id]=0; continue; }
      let keep=255;
      for(let yy=y-1;yy<=y+1;yy++){ for(let xx=x-1;xx<=x+1;xx++){
        if(xx<0||yy<0||xx>=w||yy>=h) continue;
        if(src[yy*w+xx]===0){ keep=0; break; }
      } if(!keep) break; }
      out[id]=keep;
    }} return out;
  }
  function dilate255(mask,w,h){ const src=mask, out=new Uint8ClampedArray(src.length);
    for(let y=0;y<h;y++){ for(let x=0;x<w;x++){
      const id=y*w+x; if(src[id]===255){ out[id]=255; continue; }
      let on=0;
      for(let yy=y-1;yy<=y+1;yy++){ for(let xx=x-1;xx<=x+1;xx++){
        if(xx<0||yy<0||xx>=w||yy>=h) continue;
        if(src[yy*w+xx]===255){ on=1; break; }
      } if(on) break; }
      out[id]=on?255:0;
    }} return out;
  }

  // ---------- background sample ----------
  function autoSampleBackground(c){
    const cx=c.getContext('2d'), w=c.width, h=c.height;
    const s=Math.max(6,Math.floor(Math.min(w,h)*0.06));
    const patches=[ cx.getImageData(0,0,s,s).data, cx.getImageData(w-s,0,s,s).data, cx.getImageData(0,h-s,s,s).data, cx.getImageData(w-s,h-s,s,s).data ];
    let R=0,G=0,B=0,N=0; for(const data of patches){ for(let i=0;i<data.length;i+=4){ R+=data[i]; G+=data[i+1]; B+=data[i+2]; N++; } }
    return {r:R/N, g:G/N, b:B/N};
  }

  // ---------- helper flood fill ----------
  function floodFromEdges01(mask01,w,h){
    const vis=new Uint8Array(w*h);
    const st=[]; const push=(x,y)=>st.push(x,y);
    for(let x=0;x<w;x++){ if(mask01[x]){vis[x]=1; push(x,0);} if(mask01[(h-1)*w+x]){vis[(h-1)*w+x]=1; push(x,h-1);} }
    for(let y=0;y<h;y++){ if(mask01[y*w]){vis[y*w]=1; push(0,y);} if(mask01[y*w+(w-1)]){vis[y*w+(w-1)]=1; push(w-1,y);} }
    while(st.length){
      const y=st.pop(), x=st.pop(), id=y*w+x;
      if(x>0){ const i1=id-1; if(!vis[i1] && mask01[i1]){vis[i1]=1; push(x-1,y);} }
      if(x<w-1){ const i2=id+1; if(!vis[i2] && mask01[i2]){vis[i2]=1; push(x+1,y);} }
      if(y>0){ const i3=id-w; if(!vis[i3] && mask01[i3]){vis[i3]=1; push(x,y-1);} }
      if(y<h-1){ const i4=id+w; if(!vis[i4] && mask01[i4]){vis[i4]=1; push(x,y+1);} }
    }
    return vis; // 1 = conectado a borde
  }

  // ---------- small components cleanup ----------
  function removeSmallIslands01(mask01,w,h, minAreaRatio){
    const areaMin = Math.max(8, Math.floor(w*h*minAreaRatio));
    const lab=new Int32Array(w*h).fill(-1);
    const area=[];
    let cc=0;
    for(let p=0;p<w*h;p++){
      if(mask01[p]!==1 || lab[p]!==-1) continue;
      const st=[p]; lab[p]=cc; let count=0;
      while(st.length){
        const v=st.pop(); count++;
        const x=v%w, y=(v-x)/w;
        const nbs=[v-1,v+1,v-w,v+w];
        for(let k=0;k<4;k++){
          const nb=nbs[k]; if(nb<0||nb>=w*h) continue;
          if(mask01[nb]===1 && lab[nb]===-1){ lab[nb]=cc; st.push(nb); }
        }
      }
      area[cc]=count; cc++;
    }
    for(let p=0;p<w*h;p++){
      const id=lab[p]; if(id>=0 && area[id]<areaMin) mask01[p]=0;
    }
    return mask01;
  }

  // ---------- core: m√°scara que conserva cristal (rellena huecos) ----------
  function buildMaskKeepGlass(src, T, doFillHoles, doCleanSpecks){
    const d=src.data, w=src.width, h=src.height;
    const bgLab=rgb2oklab(bg.r,bg.g,bg.b);

    // 1) candidatos a fondo por similitud al fondo
    const cand01=new Uint8Array(w*h);
    for(let i=0,p=0;i<d.length;i+=4,p++){
      const r=d[i], g=d[i+1], b=d[i+2];
      const lab=rgb2oklab(r,g,b);
      let isBg = (deltaOk(lab,bgLab) <= (T*0.9 + 0.12)); // umbral suave
      // protege blanco puro (borde blanco)
      const mx=Math.max(r,g,b), mn=Math.min(r,g,b);
      if(mx>245 && mn>225) isBg=false;
      cand01[p]=isBg?1:0;
    }

    // 2) fondo conectado a bordes (lo que s√≠ se borra)
    const bgConn01 = floodFromEdges01(cand01,w,h);

    // 3) sticker = lo que NO es fondo conectado
    let sticker01=new Uint8Array(w*h);
    for(let p=0;p<w*h;p++) sticker01[p]=bgConn01[p]?0:1;

    // 4) RELLENAR HUECOS INTERNOS (cristales/cabinas)
    if(doFillHoles){
      // Huecos = regiones de fondo NO conectadas al borde -> convi√©rtelos a sticker
      // Para hallarlos: toma "fondo total" = cand01; quita el conectado; lo que queda son huecos
      const holes01=new Uint8Array(w*h);
      for(let p=0;p<w*h;p++) holes01[p]=(cand01[p]===1 && !bgConn01[p])?1:0;
      // A√±ade huecos al sticker
      for(let p=0;p<w*h;p++) if(holes01[p]) sticker01[p]=1;
    }

    // 5) LIMPIEZA DE PUNTITOS/MANCHAS peque√±as
    if(doCleanSpecks){
      // (a) elimina peque√±as islas de sticker fuera (ruido)
      sticker01 = removeSmallIslands01(sticker01,w,h, 0.0008); // ~0.08%
      // (b) elimina peque√±as islas de fondo dentro (por seguridad)
      const inv01=new Uint8Array(w*h); for(let p=0;p<w*h;p++) inv01[p]=sticker01[p]?0:1;
      const invClean = removeSmallIslands01(inv01,w,h, 0.0008);
      for(let p=0;p<w*h;p++) sticker01[p]=invClean[p]?0:1;
    }

    // 6) anti-halo leve (recorta 1, repone 2) en 255
    let mask255=new Uint8ClampedArray(w*h);
    for(let p=0;p<w*h;p++) mask255[p]=sticker01[p]?255:0;
    mask255 = erode255(mask255,w,h);
    mask255 = dilate255(mask255,w,h);
    mask255 = dilate255(mask255,w,h);

    return mask255; // 0/255
  }

  // ---------- aplicar alfa con borde liso en banda ----------
  function applyAlphaWithSmooth(src, mask255, doSmooth, bandPx){
    const d=src.data, w=src.width, h=src.height;
    const A0=new Float32Array(mask255.length);
    for(let i=0;i<mask255.length;i++) A0[i]=mask255[i]/255;

    // banda alrededor del borde
    let boundary=new Uint8Array(w*h);
    for(let y=1;y<h-1;y++){ for(let x=1;x<w-1;x++){
      const id=y*w+x, a=A0[id];
      if(a>0 && a<1){ boundary[id]=1; continue; }
      if((A0[id-1]!==a)||(A0[id+1]!==a)||(A0[id-w]!==a)||(A0[id+w]!==a)) boundary[id]=1;
    }}
    for(let t=1;t<bandPx;t++){ // expandir banda
      boundary = dilate255(boundary,w,h);
    }

    // blur 3x3 en banda
    const A=new Float32Array(A0);
    if(doSmooth){
      const B=new Float32Array(A.length);
      for(let y=1;y<h-1;y++){ for(let x=1;x<w-1;x++){
        const id=y*w+x;
        if(boundary[id]){
          let s=0;
          s+=A[id]+A[id-1]+A[id+1]+A[id-w]+A[id+w]+A[id-w-1]+A[id-w+1]+A[id+w-1]+A[id+w+1];
          B[id]=s/9;
        }else{
          B[id]=A[id];
        }
      }}
      for(let i=0;i<A.length;i++) A[i]=B[i];
    }

    // endurecer un poquito (evita velo gris)
    for(let i=0;i<A.length;i++){
      let a=A[i];
      if(a<0.02) a=0; else if(a>0.98) a=1; else a=Math.pow(a,0.92);
      A[i]=a;
    }

    // aplicar: color intacto; blanco puro siempre opaco
    for(let i=0,p=0;i<d.length;i+=4,p++){
      const r=d[i], g=d[i+1], b=d[i+2];
      const mx=Math.max(r,g,b), mn=Math.min(r,g,b);
      if(mx>245 && mn>225){ d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=255; continue; }
      d[i+3]=Math.round(A[p]*255);
    }
    ctx.putImageData(src,0,0);
  }
})();
</script>
</body>
</html>

