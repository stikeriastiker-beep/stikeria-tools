<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Quitar Fondo ‚Äî Stikeria (auto + pincel + varita)</title>
<style>
  :root{--brand:#2c7be5;--ok:#34c38f;--warn:#e83e8c}
  body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;background:#0f1014;color:#eef1f6;margin:0;padding:20px}
  .box{max-width:860px;margin:auto;background:#151826;border:1px solid #262a3f;border-radius:16px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.35)}
  h2{margin:0 0 10px;text-align:center}
  .bar{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-bottom:10px}
  button{padding:10px 14px;border:0;border-radius:10px;font-weight:800;cursor:pointer}
  #btnUp{background:var(--brand);color:#fff}
  #btnAuto{background:var(--ok);color:#021}
  #btnDl{background:var(--warn);color:#fff}
  #btnReset{background:#444b6a;color:#fff}
  .mini{display:flex;gap:14px;flex-wrap:wrap;justify-content:center;align-items:center;margin:8px 0 12px}
  .mini label{font-size:12px;color:#cfe1ff;display:flex;align-items:center;gap:6px}
  input[type="range"]{accent-color:var(--brand)}
  .chip{background:#202540;border:1px solid #2f365c;border-radius:999px;padding:2px 8px}
  .tools{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin:8px 0}
  .tbtn{padding:8px 12px;border-radius:10px;border:1px solid #2f365c;background:#1a1f36;color:#dfe7ff;font-weight:700;cursor:pointer}
  .tbtn.active{outline:2px solid var(--brand);background:#172245}
  .stage{display:grid;place-items:center}
  #cv{max-width:100%;background:conic-gradient(#e5e7eb 0 25%, transparent 0 50%, #e5e7eb 0 75%, transparent 0) 0 0/20px 20px;border-radius:12px;cursor:crosshair}
</style>
</head>
<body>
<div class="box">
  <h2>Quitar Fondo ‚Äî Stikeria (auto + pincel + varita)</h2>

  <div class="bar">
    <button id="btnUp">Subir</button>
    <input id="file" type="file" accept="image/png,image/jpeg,image/webp" style="display:none">
    <button id="btnAuto" disabled>Quitar fondo (auto)</button>
    <button id="btnReset" disabled>Restaurar original</button>
    <button id="btnDl" disabled>Descargar 512√ó512</button>
  </div>

  <div class="mini">
    <label>üéØ Fondo:
      <select id="bgMode">
        <option value="auto">Auto (esquinas)</option>
        <option value="click">Elegir con clic</option>
      </select>
      <span id="bgChip" class="chip">auto</span>
    </label>
    <label>üéöÔ∏è Tolerancia
      <input id="tol" type="range" min="20" max="100" value="60">
      <span id="tolv" class="chip">60</span>
    </label>
    <label>üß∑ Borde liso (px)
      <input id="band" type="range" min="1" max="4" value="2">
      <span id="bandv" class="chip">2</span>
    </label>
    <label><input id="fillHoles" type="checkbox" checked> Rellenar huecos internos</label>
    <label><input id="cleanSpecks" type="checkbox" checked> Quitar puntitos</label>
  </div>

  <div class="tools">
    <button class="tbtn active" id="toolErase">üßº Borrar fondo</button>
    <button class="tbtn" id="toolRestore">üé® Recuperar dibujo</button>
    <button class="tbtn" id="toolWandErase">üîÆ Varita borrar</button>
    <button class="tbtn" id="toolWandRestore">üîÆ Varita recuperar</button>
    <label>üåï Tama√±o pincel
      <input id="brush" type="range" min="4" max="80" value="26">
      <span id="bv" class="chip">26</span>
    </label>
    <label>‚ú® Tolerancia varita
      <input id="wandTol" type="range" min="5" max="120" value="40">
      <span id="wv" class="chip">40</span>
    </label>
    <label>üîç Zoom
      <input id="zoom" type="range" min="1" max="4" value="1" step="0.1">
      <span id="zv" class="chip">1.0√ó</span>
    </label>
  </div>

  <div class="stage">
    <canvas id="cv" width="768" height="768" title="Auto: clic en fondo si lo eliges. Pincel: arrastra. Varita: un clic dentro del √°rea."></canvas>
  </div>
</div>

<script>
(function(){
  const $=id=>document.getElementById(id);
  const cv=$('cv'), ctx=cv.getContext('2d',{willReadFrequently:true});
  const btnUp=$('btnUp'), file=$('file'), btnAuto=$('btnAuto'), btnReset=$('btnReset'), btnDl=$('btnDl');
  const tol=$('tol'), tolv=$('tolv'), band=$('band'), bandv=$('bandv'), fillHoles=$('fillHoles'), cleanSpecks=$('cleanSpecks');
  const bgMode=$('bgMode'), bgChip=$('bgChip');
  const toolErase=$('toolErase'), toolRestore=$('toolRestore'), toolWandErase=$('toolWandErase'), toolWandRestore=$('toolWandRestore');
  const brush=$('brush'), bv=$('bv'), wandTol=$('wandTol'), wv=$('wv'), zoom=$('zoom'), zv=$('zv');

  let W=0,H=0, imgOrig=null, work=null, workCtx=null;
  let bg={r:255,g:255,b:255};
  let tool='erase'; // 'erase'|'restore'|'wand-erase'|'wand-restore'
  let scale=1, offX=0, offY=0;
  let drawing=false;

  // offscreen
  const off=document.createElement('canvas'); const offCtx=off.getContext('2d',{willReadFrequently:true});

  // UI
  tol.oninput=()=>tolv.textContent=tol.value;
  band.oninput=()=>bandv.textContent=band.value;
  brush.oninput=()=>bv.textContent=brush.value;
  wandTol.oninput=()=>wv.textContent=wandTol.value;
  zoom.oninput=()=>{ zv.textContent=Number(zoom.value).toFixed(1)+'√ó'; scale=+zoom.value; draw(); };
  bgMode.onchange=()=>{ bgChip.textContent=bgMode.value==='auto'?'auto':'clic'; };

  function setActive(t){
    tool=t;
    [toolErase,toolRestore,toolWandErase,toolWandRestore].forEach(b=>b.classList.remove('active'));
    if(t==='erase') toolErase.classList.add('active');
    if(t==='restore') toolRestore.classList.add('active');
    if(t==='wand-erase') toolWandErase.classList.add('active');
    if(t==='wand-restore') toolWandRestore.classList.add('active');
  }
  toolErase.onclick =()=>setActive('erase');
  toolRestore.onclick=()=>setActive('restore');
  toolWandErase.onclick =()=>setActive('wand-erase');
  toolWandRestore.onclick=()=>setActive('wand-restore');

  btnUp.onclick=()=>file.click();
  file.onchange=e=>{
    const f=e.target.files?.[0]; if(!f) return;
    const im=new Image();
    im.onload=()=>{
      W=im.naturalWidth; H=im.naturalHeight;
      const LIM=1600, r=Math.min(1, LIM/Math.max(W,H));
      const w=(W*r)|0, h=(H*r)|0;
      off.width=w; off.height=h; offCtx.clearRect(0,0,w,h); offCtx.drawImage(im,0,0,w,h);
      imgOrig=offCtx.getImageData(0,0,w,h);
      workCtx=offCtx; work=off;
      cv.width=w; cv.height=h; scale=1; zoom.value=1; zv.textContent='1.0√ó';
      bg = autoSampleBackground(off); setChip(bg);
      btnAuto.disabled=false; btnDl.disabled=false; btnReset.disabled=false;
      draw();
    };
    im.src=URL.createObjectURL(f);
  };

  cv.addEventListener('click', e=>{
    if(!imgOrig) return;
    if(bgMode.value==="click" && (tool==='erase' || tool==='restore')){ // elegir fondo con clic (modo normal)
      const {x,y}=toImageXY(e);
      const p=workCtx.getImageData(x,y,1,1).data;
      bg={r:p[0],g:p[1],b:p[2]}; setChip(bg); return;
    }
    // Varita
    if(tool==='wand-erase' || tool==='wand-restore'){
      const {x,y}=toImageXY(e);
      wandFill(x,y, +wandTol.value, tool==='wand-erase'); // erase=true|false
      draw();
    }
  });

  btnAuto.onclick=()=>{
    if(!imgOrig) return;
    if(bgMode.value==="auto"){ bg=autoSampleBackground(off); setChip(bg); }
    let cur=workCtx.getImageData(0,0,off.width,off.height);
    const mask = buildMask(cur, Number(tol.value)/100, fillHoles.checked, cleanSpecks.checked, bg);
    applyAlphaWithSmooth(cur, mask, Number(band.value), bg);
    workCtx.putImageData(cur,0,0);
    draw();
  };

  btnReset.onclick=()=>{
    if(!imgOrig) return;
    workCtx.putImageData(imgOrig,0,0);
    draw();
  };

  btnDl.onclick=()=>{
    if(!imgOrig) return;
    const OUT=512;
    const out=document.createElement('canvas'); out.width=OUT; out.height=OUT;
    const c=out.getContext('2d');
    c.imageSmoothingEnabled=true; c.imageSmoothingQuality='high';
    const iw=off.width, ih=off.height;
    const s=Math.min(OUT/iw, OUT/ih), nw=Math.round(iw*s), nh=Math.round(ih*s);
    // construir alfa
    const tmp=document.createElement('canvas'); tmp.width=nw; tmp.height=nh;
    const tctx=tmp.getContext('2d');
    tctx.imageSmoothingEnabled=true; tctx.drawImage(off,0,0,nw,nh);
    const im=tctx.getImageData(0,0,nw,nh);
    const A=new Uint8ClampedArray(nw*nh);
    for(let i=0,p=0;i<im.data.length;i+=4,p++) A[p]=im.data[i+3];
    // borde blanco ~2%
    const outline = Math.max(2, Math.round(Math.max(nw,nh)*0.02));
    let M=A.slice();
    for(let it=0; it<outline; it++) M = dilateAlpha01(M,nw,nh);
    // blanco debajo
    const white=document.createElement('canvas'); white.width=nw; white.height=nh;
    const wctx=white.getContext('2d');
    const wimg=wctx.createImageData(nw,nh);
    for(let p=0, i=0; p<M.length; p++, i+=4){
      const a = M[p], a0= A[p];
      if(a>0 && a0===0){ wimg.data[i]=255; wimg.data[i+1]=255; wimg.data[i+2]=255; wimg.data[i+3]=255; }
    }
    wctx.putImageData(wimg,0,0);
    c.clearRect(0,0,OUT,OUT);
    c.drawImage(white,(OUT-nw)/2,(OUT-nh)/2);
    c.drawImage(tmp,(OUT-nw)/2,(OUT-nh)/2);
    const a=document.createElement('a'); a.download='sticker_512.png'; a.href=out.toDataURL('image/png'); a.click();
  };

  function setChip(c){ bgChip.textContent=`rgb(${c.r|0},${c.g|0},${c.b|0})`; }

  // ======= Pinceles =======
  cv.addEventListener('pointerdown',e=>{ if(!imgOrig) return; if(tool==='erase'||tool==='restore'){ drawing=true; paint(e);} });
  cv.addEventListener('pointermove',e=>{ if(drawing) paint(e); });
  window.addEventListener('pointerup',()=>drawing=false);

  function paint(e){
    const r=+brush.value;
    const {x,y}=toImageXY(e);
    const img=workCtx.getImageData(0,0,off.width,off.height);
    const d=img.data, w=img.width, h=img.height;
    const rr=r*r;
    const x0=Math.max(0, x-r|0), x1=Math.min(w-1, x+r|0);
    const y0=Math.max(0, y-r|0), y1=Math.min(h-1, y+r|0);
    for(let yy=y0; yy<=y1; yy++){
      for(let xx=x0; xx<=x1; xx++){
        const dx=xx-x, dy=yy-y;
        if(dx*dx+dy*dy<=rr){
          const i=(yy*w+xx)*4+3;
          d[i]=(tool==='erase')?0:255;
        }
      }
    }
    workCtx.putImageData(img,0,0);
    draw();
  }

  // ======= Varita m√°gica (flood por color) =======
  function wandFill(x,y,thr, erase){
    const img=workCtx.getImageData(0,0,off.width,off.height);
    const d=img.data, w=img.width, h=img.height;
    const i0=(y*w+x)*4; const sr=d[i0], sg=d[i0+1], sb=d[i0+2], sa=d[i0+3];
    const visited=new Uint8Array(w*h);
    const st=[x,y]; visited[y*w+x]=1;

    // Umbral RGB: usamos distancia manhattan |dr|+|dg|+|db|
    const T = thr; // 5..120 aprox sensible

    while(st.length){
      const yy=st.pop(), xx=st.pop();
      const idx=(yy*w+xx)*4;
      const r=d[idx], g=d[idx+1], b=d[idx+2], a=d[idx+3];

      const dist=Math.abs(r-sr)+Math.abs(g-sg)+Math.abs(b-sb);
      // Solo expandimos si el color es parecido al del punto inicial
      if(dist<=T){
        d[idx+3]= erase ? 0 : 255; // editamos SOLO alfa
        // vecinos 4-conexi√≥n
        if(xx>0 && !visited[yy*w+xx-1]){ visited[yy*w+xx-1]=1; st.push(xx-1,yy); }
        if(xx<w-1 && !visited[yy*w+xx+1]){ visited[yy*w+xx+1]=1; st.push(xx+1,yy); }
        if(yy>0 && !visited[(yy-1)*w+xx]){ visited[(yy-1)*w+xx]=1; st.push(xx,yy-1); }
        if(yy<h-1 && !visited[(yy+1)*w+xx]){ visited[(yy+1)*w+xx]=1; st.push(xx,yy+1); }
      }
    }
    workCtx.putImageData(img,0,0);
  }

  function toImageXY(e){
    const rect=cv.getBoundingClientRect();
    const vx=(e.clientX-rect.left)/rect.width;
    const vy=(e.clientY-rect.top)/rect.height;
    const x=Math.round((vx*cv.width - offX)/scale);
    const y=Math.round((vy*cv.height- offY)/scale);
    return {x:Math.max(0,Math.min(off.width-1,x)), y:Math.max(0,Math.min(off.height-1,y))};
  }

  // ======= Render con zoom =======
  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,cv.width,cv.height);
    const cx=cv.width, cy=cv.height;
    const dw=off.width*scale, dh=off.height*scale;
    offX=(cx-dw)/2; offY=(cy-dh)/2;
    ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
    ctx.drawImage(off, offX, offY, dw, dh);
  }

  // ======= Auto fondo =======
  function autoSampleBackground(c){
    const w=c.width,h=c.height, s=Math.max(6,Math.floor(Math.min(w,h)*0.06));
    const g=c.getContext('2d');
    const patches=[ g.getImageData(0,0,s,s).data, g.getImageData(w-s,0,s,s).data, g.getImageData(0,h-s,s,s).data, g.getImageData(w-s,h-s,s,s).data ];
    let R=0,G=0,B=0,N=0; for(const data of patches){ for(let i=0;i<data.length;i+=4){ R+=data[i]; G+=data[i+1]; B+=data[i+2]; N++; } }
    return {r:R/N,g:G/N,b:B/N};
  }

  // ======= M√°scara auto conservadora =======
  function buildMask(src, T, doFillHoles, doCleanSpecks, bg){
    const d=src.data, w=src.width, h=src.height;
    const cand=new Uint8Array(w*h);
    for(let i=0,p=0;i<d.length;i+=4,p++){
      const r=d[i], g=d[i+1], b=d[i+2];
      const white = Math.max(r,g,b)>245 && Math.min(r,g,b)>225;
      const dist=Math.sqrt((r-bg.r)*(r-bg.r)+(g-bg.g)*(g-bg.g)+(b-bg.b)*(b-bg.b))/442;
      let isBg = dist <= T; if(white) isBg=false;
      cand[p]=isBg?1:0;
    }
    const bgConn=floodFromEdges01(cand, w, h);
    let stick=new Uint8Array(w*h);
    for(let p=0;p<w*h;p++) stick[p]=bgConn[p]?0:1;

    if(doFillHoles){
      const holes=new Uint8Array(w*h);
      for(let p=0;p<w*h;p++) holes[p]=(cand[p]===1 && !bgConn[p])?1:0;
      for(let p=0;p<w*h;p++) if(holes[p]) stick[p]=1;
    }
    if(doCleanSpecks){
      stick = removeSmallIslands01(stick, w, h, 0.0007);
      const inv=new Uint8Array(w*h); for(let p=0;p<w*h;p++) inv[p]=stick[p]?0:1;
      const invClean=removeSmallIslands01(inv, w, h, 0.0007);
      for(let p=0;p<w*h;p++) stick[p]=invClean[p]?0:1;
    }
    const mask=new Uint8ClampedArray(w*h);
    for(let p=0;p<w*h;p++) mask[p]=stick[p]?255:0;
    return mask;
  }

  function applyAlphaWithSmooth(src, mask, bandPx, bg){
    const d=src.data, w=src.width, h=src.height;
    const A=new Float32Array(mask.length); for(let i=0;i<mask.length;i++) A[i]=mask[i]/255;
    let boundary=new Uint8Array(w*h);
    for(let y=1;y<h-1;y++){ for(let x=1;x<w-1;x++){
      const id=y*w+x;
      if(A[id]===1 && (A[id-1]===0 || A[id+1]===0 || A[id-w]===0 || A[id+w]===0)) boundary[id]=1;
    }}
    for(let t=1;t<bandPx;t++) boundary=dilate255(boundary,w,h);
    const B=new Float32Array(A.length);
    for(let y=1;y<h-1;y++){ for(let x=1;x<w-1;x++){
      const id=y*w+x;
      if(boundary[id]){
        let s=0; s+=A[id]+A[id-1]+A[id+1]+A[id-w]+A[id+w]+A[id-w-1]+A[id-w+1]+A[id+w-1]+A[id+w+1];
        B[id]=s/9;
      }else B[id]=A[id];
    }}
    for(let i=0;i<A.length;i++){
      let a=B[i]; if(a<0.02) a=0; else if(a>0.98) a=1; else a=Math.pow(a,0.92); A[i]=a;
    }
    for(let i=0,p=0;i<d.length;i+=4,p++){
      const r=d[i], g=d[i+1], b=d[i+2];
      const white = (Math.max(r,g,b)>245 && Math.min(r,g,b)>225);
      if(white){ d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=255; continue; }
      d[i+3]=Math.round(A[p]*255);
    }
  }

  // ======= util flood/morfolog√≠a =======
  function floodFromEdges01(mask01,w,h){
    const vis=new Uint8Array(w*h); const st=[]; const push=(x,y)=>st.push(x,y);
    for(let x=0;x<w;x++){ if(mask01[x]){vis[x]=1; push(x,0);} if(mask01[(h-1)*w+x]){vis[(h-1)*w+x]=1; push(x,h-1);} }
    for(let y=0;y<h;y++){ if(mask01[y*w]){vis[y*w]=1; push(0,y);} if(mask01[y*w+(w-1)]){vis[y*w+(w-1)]=1; push(w-1,y);} }
    while(st.length){
      const y=st.pop(), x=st.pop(), id=y*w+x;
      if(x>0){ const i1=id-1; if(!vis[i1] && mask01[i1]){vis[i1]=1; push(x-1,y);} }
      if(x<w-1){ const i2=id+1; if(!vis[i2] && mask01[i2]){vis[i2]=1; push(x+1,y);} }
      if(y>0){ const i3=id-w; if(!vis[i3] && mask01[i3]){vis[i3]=1; push(x,y-1);} }
      if(y<h-1){ const i4=id+w; if(!vis[i4] && mask01[i4]){vis[i4]=1; push(x,y+1);} }
    }
    return vis;
  }
  function removeSmallIslands01(mask01,w,h,minAreaRatio){
    const minA=Math.max(8,Math.floor(w*h*minAreaRatio));
    const lab=new Int32Array(w*h).fill(-1); const area=[]; let cc=0;
    for(let p=0;p<w*h;p++){
      if(mask01[p]!==1 || lab[p]!==-1) continue;
      const st=[p]; lab[p]=cc; let count=0;
      while(st.length){
        const v=st.pop(); count++;
        const x=v%w, y=(v-x)/w;
        const nbs=[v-1,v+1,v-w,v+w];
        for(let k=0;k<4;k++){
          const nb=nbs[k]; if(nb<0||nb>=w*h) continue;
          if(mask01[nb]===1 && lab[nb]===-1){ lab[nb]=cc; st.push(nb); }
        }
      }
      area[cc]=count; cc++;
    }
    for(let p=0;p<w*h;p++){ const id=lab[p]; if(id>=0 && area[id]<minA) mask01[p]=0; }
    return mask01;
  }
  function dilate255(mask,w,h){
    const src=mask, out=new Uint8ClampedArray(src.length);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const id=y*w+x; if(src[id]){ out[id]=255; continue; }
        let on=0;
        for(let yy=0;yy<3;yy++){ for(let xx=0;xx<3;xx++){
          const X=x+xx-1, Y=y+yy-1;
          if(X<0||Y<0||X>=w||Y>=h) continue;
          if(src[Y*w+X]){ on=1; break; }
        } if(on) break; }
        out[id]=on?255:0;
      }
    }
    return out;
  }
  function dilateAlpha01(A,w,h){
    const out=new Uint8ClampedArray(A.length);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const id=y*w+x;
        if(A[id]>0){ out[id]=255; continue; }
        let on=0;
        for(let yy=0;yy<3;yy++){ for(let xx=0;xx<3;xx++){
          const X=x+xx-1, Y=y+yy-1;
          if(X<0||Y<0||X>=w||Y>=h) continue;
          if(A[Y*w+X]>0){ on=1; break; }
        } if(on) break; }
        out[id]=on?255:0;
      }
    }
    return out;
  }
})();
</script>
</body>
</html>
